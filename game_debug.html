<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta charset="utf-8" />
        <title>Yie Ar Sint Fu</title>
        <meta name="viewport"
            content="width=device-width,initial-scale=1.0,minimum-scale=1,maximum-scale=1,user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <meta name="apple-mobile-web-app-title" content="Yie Ar Sint Fu">
        <link rel="manifest" href="manifest.webmanifest">
        <link rel="apple-touch-icon" href="bmsx_icon.png">
        <link rel="icon" type="image/png" href="bmsx_icon.png">
        <link rel="shortcut icon" type="image/x-icon" href="bmsx_icon.png">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
        <script id="bootrom">"use strict";

const bootrom = {
    rom: null,
    debug: false,
    romname: undefined,
    sndcontext: null,
    snd_unlocked: false,
    gainnode: null,
    theshowsover: false,
    set defusr(rom) {
        bootrom.rom = rom;
    },
    usr(x) {
        var _a, _b;
        const remove = (id) => {
            let element = document.querySelector(id);
            if (element)
                element.parentElement.removeChild(element);
        };
        const wrapup = () => {
            document.querySelector('#loading').hidden = true;
            remove('#msx');
            remove('#hidor');
            remove('#romjs');
            document.body.classList.add('game-started');
        };
        try {
            if (!h406A)
                throw new Error('h406A is not defined!');
            document.getElementById('gamescreen').hidden = false;
            document.getElementById('gamescreen').style.display = 'block';
            h406A(bootrom.rom, bootrom.sndcontext, bootrom.gainnode, this.debug);
            wrapup();
            bootrom.rom = undefined;
            return 255;
        }
        catch (err) {
            console.error(err);
            document.getElementById('gamescreen').hidden = true;
            document.getElementById('gamescreen').style.display = 'none';
            throw new Error(`Error in usr(0): "${(_b = (_a = err === null || err === void 0 ? void 0 : err.message) !== null && _a !== void 0 ? _a : err) !== null && _b !== void 0 ? _b : 'unknown error :-('}"`);
        }
    },
    async bload(url) {
        window.onunhandledrejection = (event) => {
            var _a, _b, _c;
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            const reason = (_c = (_b = (_a = event.reason) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : event.reason) !== null && _c !== void 0 ? _c : 'unkown error';
            const errormsg = `Unhandled rejection during "bload"-command: "${reason}".`;
            throw new Error(errormsg);
        };
        createAudioContext();
        const fetchRom = () => {
            return fetchBuffer(url).catch(err => {
                throw new Error(`Error while fetching ROM: "${err.message}"`);
            });
        };
        return new Promise((resolve, reject) => {
            let loadedRomPack = null;
            let romlabel_bloburl = undefined;
            fetchRom()
                .then((response_array) => getZippedRomAndRomLabelFromBlob(response_array))
                .then((ziprom_and_label) => {
                romlabel_bloburl = ziprom_and_label.romlabel;
                return pako.inflate(ziprom_and_label.zipped_rom).buffer;
            })
                .then(rom => loadResources(rom))
                .then((loadResult) => {
                loadedRomPack = loadResult;
                awaitBootComplete();
            })
                .then(() => loadScript(loadedRomPack, bootrom.romname))
                .then(() => {
                setLoaderText('Press any key or touch screen to start...');
                setClassForLoader('');
                return awaitPressedAnyKeyPromise();
            })
                .then(() => resolve(loadedRomPack))
                .catch(err => {
                reject(err);
            });
        });
    },
    outputError(errormsg) {
        console.error(errormsg);
        bootrom.theshowsover = true;
        const loadingElement = document.querySelector('#loading');
        if (loadingElement)
            loadingElement.hidden = false;
        const msxElement = document.querySelector('#msx');
        if (msxElement)
            msxElement.onanimationend = undefined;
        const hidorElement = document.querySelector('#hidor');
        if (hidorElement)
            hidorElement.className = 'showsover';
        document.body.className = "showsover";
        setClassForLoader('');
        setLoaderText(errormsg);
    }
};
function getRomFromUrlParameter() {
    const rom = getParameterByName('rom');
    return rom && rom !== '' ? rom : null;
}
function getRomNameFromUrlParameter() {
    const rom_name = getParameterByName('romname');
    return rom_name && rom_name !== '' ? rom_name : null;
}
function getParameterByName(name, url = window.location.href) {
    name = name.replace(/[\[\]]/g, '\\//#romjs');
    var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'), results = regex.exec(url);
    if (!results)
        return null;
    if (!results[2])
        return '';
    return decodeURIComponent(results[2].replace(/\+/g, ' '));
}
async function loadImage(url) {
    return new Promise((resolve, reject) => {
        let img = new Image();
        img.onload = e => resolve(img);
        img.onerror = e => {
            reject(`Failed to load image's URL: ${url}`);
        };
        img.src = url;
    });
}
function parseMetaFromBuffer(to_parse) {
    let bytearray = new Uint8Array(to_parse);
    let sliced = bytearray.slice(bytearray.length - 100);
    let metaJsonStr = decodeuint8arr(sliced);
    return JSON.parse(metaJsonStr);
}
function getSubBufferAsPerMeta(buffer, meta) {
    return buffer.slice(meta.start, meta.end);
}
function getSubBufferFromBufferWithMeta(buffer) {
    let buffer_meta = parseMetaFromBuffer(buffer);
    return getSubBufferAsPerMeta(buffer, buffer_meta);
}
async function getZippedRomAndRomLabelFromBlob(blob_buffer) {
    try {
        return { zipped_rom: getSubBufferFromBufferWithMeta(blob_buffer), romlabel: undefined };
    }
    catch (err) {
        throw new Error(`Error in getZippedRomAndRomLabelFromBlob: "${err.message}"`);
    }
}
async function loadResourceList(rom) {
    let sliced = new Uint8Array(getSubBufferFromBufferWithMeta(rom));
    let resJsonStr = decodeuint8arr(sliced);
    let resJson = JSON.parse(resJsonStr);
    return Promise.resolve(resJson);
}
async function loadResources(rom) {
    let result = {
        images: {},
        rom: rom,
        img_assets: {},
        snd_assets: {},
        code: null
    };
    let list = await loadResourceList(rom);
    for (let i = 0; i < list.length; i++) {
        await load(rom, list[i], result);
    }
    return Promise.resolve(result);
}
function getImageURL(buffer) {
    let mime;
    let blub;
    mime = 'image/png';
    blub = new Blob([new Uint8Array(buffer)], { type: mime });
    return URL.createObjectURL(blub);
}
async function getImageFromBuffer(buffer) {
    let url = getImageURL(buffer);
    return loadImage(url);
}
async function load(rom, res, romResult) {
    switch (res.type) {
        case 'image':
            if (!res.imgmeta.atlassed) {
                let img = await getImageFromBuffer(rom.slice(res.start, res.end));
                romResult.images[res.resid] = img;
                romResult.images[res.resname] = img;
            }
            romResult.img_assets[res.resid] = res;
            romResult.img_assets[res.resname] = res;
            break;
        case 'source':
            try {
                let bytearray = new Uint8Array(rom);
                let sliced = bytearray.slice(res.start, res.end);
                romResult.code = decodeuint8arr(sliced);
            }
            catch (err) {
                throw new Error(`Failed to load 'source' from rom: ${err.message}.`);
            }
            break;
        case 'audio':
            romResult.snd_assets[res.resid] = res;
            romResult.snd_assets[res.resname] = res;
            break;
        default:
            throw new Error(`Unrecognised resource type in rom: ${res.type}, while processing rompack!`);
    }
}
async function awaitBootComplete() {
    let result = new Promise((resolve, reject) => {
        let msx = document.querySelector('#msx');
        msx.onanimationend = ev => {
            let loading = document.querySelector('#loading');
            loading.hidden = false;
            bootrom.theshowsover = true;
            resolve();
        };
        msx.className = "enter";
        msx.hidden = false;
        if (bootrom.debug)
            resolve();
    });
    return result;
}
async function loadScript(rom, romname) {
    try {
        let scriptText;
        let scriptUrl;
        if (!bootrom.debug) {
            scriptText = rom.code;
        }
        else {
            const romUrl = `../${romname}.js`;
            scriptUrl = romUrl;
        }
        let romcode = document.createElement('script');
        romcode.async = false;
        if (!bootrom.debug) {
            romcode.textContent = scriptText;
            document.head.appendChild(romcode);
        }
        else {
            romcode.onload = () => {
                Promise.resolve();
            };
            romcode.src = scriptUrl;
            document.head.appendChild(romcode);
        }
    }
    catch (err) {
        throw new Error(`Error in loadScript: ${err.message}`);
    }
}
async function awaitPressedAnyKeyPromise() {
    const result = new Promise((resolve, reject) => {
        const onuserinteraction = (e) => {
            try {
                if (!bootrom.snd_unlocked || !bootrom.theshowsover) {
                    if (bootrom.debug) {
                        console.info(`Did not start game on user interaction because either the sound was not unlocked (bootrom.snd_unlocked=${bootrom.snd_unlocked}) or the boot animation had not ended (bootrom.theshowsover=${bootrom.theshowsover}).`);
                    }
                    return;
                }
                if (e.type == 'touchend') {
                    document.getElementById("d-pad-controls").hidden = false;
                    document.getElementById("button-controls").hidden = false;
                    document.documentElement.setAttribute("style", "touch-action: none;");
                    document.documentElement.setAttribute("style", "pointer-events: none;");
                }
                document.body.removeEventListener('keyup', onuserinteraction);
                document.body.removeEventListener('touchend', onuserinteraction);
                resolve();
            }
            catch (err) {
                reject(err);
            }
        };
        document.addEventListener('keyup', startAudioOnIos, true);
        document.addEventListener('touchend', startAudioOnIos, true);
        document.body.addEventListener('keyup', onuserinteraction, { passive: false, once: false, capture: false });
        document.body.addEventListener('touchend', onuserinteraction, { passive: false, once: false, capture: false });
    });
    return result;
}
function setLoaderText(txt) {
    let loading = document.querySelector('#loading');
    loading.innerText = txt;
}
function setClassForLoader(cls) {
    let loading = document.querySelector('#loading');
    loading.className = cls;
}
function decodeuint8arr(to_decode) {
    const decoder = new TextDecoder("utf-8", { fatal: true });
    try {
        return decoder.decode(to_decode);
    }
    catch (err) {
        throw err;
    }
}
async function fetchText(url) {
    try {
        const response = await fetch(url, {
            headers: {
                'Cache-Control': 'no-cache'
            }
        });
        if (!response.ok) {
            throw new Error(`Failed @fetchText for URL "${url}"`);
        }
        const decoder = new TextDecoder('utf-8');
        const data = await response.arrayBuffer();
        return decoder.decode(data);
    }
    catch (err) {
        throw new Error(`Error @fetchText for URL "${url}": ${err.message}`);
    }
}
async function fetchBuffer(url) {
    try {
        const response = await fetch(url, {
            headers: {
                'Cache-Control': 'no-cache'
            }
        });
        if (!response.ok) {
            throw new Error(`Failed @fetchBuffer for URL "${url}"`);
        }
        return await response.arrayBuffer();
    }
    catch (err) {
        throw new Error(`Error @fetchBuffer for URL "${url}": ${err.message}`);
    }
}
function removeEventListeners() {
    document.removeEventListener('keyup', startAudioOnIos, true);
    document.removeEventListener('touchend', startAudioOnIos, true);
}
function startAudioOnIos() {
    if (!bootrom.sndcontext)
        return;
    if (bootrom.snd_unlocked) {
        removeEventListeners();
        return;
    }
    var source = bootrom.sndcontext.createBufferSource();
    source.buffer = bootrom.sndcontext.createBuffer(1, 1, 44100);
    source.connect(bootrom.sndcontext.destination);
    source.start(0, 0, 0);
    if (bootrom.sndcontext.state == 'running') {
        removeEventListeners();
        bootrom.snd_unlocked = true;
    }
}
function createAudioContext() {
    if (bootrom.sndcontext)
        return;
    const AContext = window.AudioContext ||
        window.webkitAudioContext;
    let context = new AContext({
        latencyHint: 'interactive',
        sampleRate: 44100,
    });
    if (/(iPhone|iPad)/i.test(navigator.userAgent) && context.sampleRate !== 44100) {
        var buffer = context.createBuffer(1, 1, 44100), dummy = context.createBufferSource();
        dummy.buffer = buffer;
        dummy.connect(context.destination);
        dummy.start(0);
        dummy.disconnect();
        context.close();
        context = new AContext();
    }
    bootrom.sndcontext = context;
}
</script>
        <script id="pacojs" distributedby="http://nodeca.github.io/pako/">/*! pako 2.0.2 https://github.com/nodeca/pako @license (MIT AND Zlib) */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).pako = {}); }(this, (function (e) { "use strict"; var t = (e, t, i, n) => { let a = 65535 & e | 0, r = e >>> 16 & 65535 | 0, s = 0; for (; 0 !== i;) { s = i > 2e3 ? 2e3 : i, i -= s; do { a = a + t[n++] | 0, r = r + a | 0; } while (--s); a %= 65521, r %= 65521; } return a | r << 16 | 0; }; const i = new Uint32Array((() => { let e, t = []; for (var i = 0; i < 256; i++) { e = i; for (var n = 0; n < 8; n++)e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1; t[i] = e; } return t; })()); var n = (e, t, n, a) => { const r = i, s = a + n; e ^= -1; for (let i = a; i < s; i++)e = e >>> 8 ^ r[255 & (e ^ t[i])]; return -1 ^ e; }; var a = function (e, t) { let i, n, a, r, s, o, l, d, f, h, c, u, w, b, k, m, _, g, v, p, y, x, E, R; const A = e.state; i = e.next_in, E = e.input, n = i + (e.avail_in - 5), a = e.next_out, R = e.output, r = a - (t - e.avail_out), s = a + (e.avail_out - 257), o = A.dmax, l = A.wsize, d = A.whave, f = A.wnext, h = A.window, c = A.hold, u = A.bits, w = A.lencode, b = A.distcode, k = (1 << A.lenbits) - 1, m = (1 << A.distbits) - 1; e: do { u < 15 && (c += E[i++] << u, u += 8, c += E[i++] << u, u += 8), _ = w[c & k]; t: for (; ;) { if (g = _ >>> 24, c >>>= g, u -= g, g = _ >>> 16 & 255, 0 === g) R[a++] = 65535 & _; else { if (!(16 & g)) { if (0 == (64 & g)) { _ = w[(65535 & _) + (c & (1 << g) - 1)]; continue t; } if (32 & g) { A.mode = 12; break e; } e.msg = "invalid literal/length code", A.mode = 30; break e; } v = 65535 & _, g &= 15, g && (u < g && (c += E[i++] << u, u += 8), v += c & (1 << g) - 1, c >>>= g, u -= g), u < 15 && (c += E[i++] << u, u += 8, c += E[i++] << u, u += 8), _ = b[c & m]; i: for (; ;) { if (g = _ >>> 24, c >>>= g, u -= g, g = _ >>> 16 & 255, !(16 & g)) { if (0 == (64 & g)) { _ = b[(65535 & _) + (c & (1 << g) - 1)]; continue i; } e.msg = "invalid distance code", A.mode = 30; break e; } if (p = 65535 & _, g &= 15, u < g && (c += E[i++] << u, u += 8, u < g && (c += E[i++] << u, u += 8)), p += c & (1 << g) - 1, p > o) { e.msg = "invalid distance too far back", A.mode = 30; break e; } if (c >>>= g, u -= g, g = a - r, p > g) { if (g = p - g, g > d && A.sane) { e.msg = "invalid distance too far back", A.mode = 30; break e; } if (y = 0, x = h, 0 === f) { if (y += l - g, g < v) { v -= g; do { R[a++] = h[y++]; } while (--g); y = a - p, x = R; } } else if (f < g) { if (y += l + f - g, g -= f, g < v) { v -= g; do { R[a++] = h[y++]; } while (--g); if (y = 0, f < v) { g = f, v -= g; do { R[a++] = h[y++]; } while (--g); y = a - p, x = R; } } } else if (y += f - g, g < v) { v -= g; do { R[a++] = h[y++]; } while (--g); y = a - p, x = R; } for (; v > 2;)R[a++] = x[y++], R[a++] = x[y++], R[a++] = x[y++], v -= 3; v && (R[a++] = x[y++], v > 1 && (R[a++] = x[y++])); } else { y = a - p; do { R[a++] = R[y++], R[a++] = R[y++], R[a++] = R[y++], v -= 3; } while (v > 2); v && (R[a++] = R[y++], v > 1 && (R[a++] = R[y++])); } break; } } break; } } while (i < n && a < s); v = u >> 3, i -= v, u -= v << 3, c &= (1 << u) - 1, e.next_in = i, e.next_out = a, e.avail_in = i < n ? n - i + 5 : 5 - (i - n), e.avail_out = a < s ? s - a + 257 : 257 - (a - s), A.hold = c, A.bits = u; }; const r = 15, s = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), o = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]), l = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]), d = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]); var f = (e, t, i, n, a, f, h, c) => { const u = c.bits; let w, b, k, m, _, g, v = 0, p = 0, y = 0, x = 0, E = 0, R = 0, A = 0, Z = 0, S = 0, O = 0, U = null, T = 0; const D = new Uint16Array(16), I = new Uint16Array(16); let B, N, C, z = null, F = 0; for (v = 0; v <= r; v++)D[v] = 0; for (p = 0; p < n; p++)D[t[i + p]]++; for (E = u, x = r; x >= 1 && 0 === D[x]; x--); if (E > x && (E = x), 0 === x) return a[f++] = 20971520, a[f++] = 20971520, c.bits = 1, 0; for (y = 1; y < x && 0 === D[y]; y++); for (E < y && (E = y), Z = 1, v = 1; v <= r; v++)if (Z <<= 1, Z -= D[v], Z < 0) return -1; if (Z > 0 && (0 === e || 1 !== x)) return -1; for (I[1] = 0, v = 1; v < r; v++)I[v + 1] = I[v] + D[v]; for (p = 0; p < n; p++)0 !== t[i + p] && (h[I[t[i + p]]++] = p); if (0 === e ? (U = z = h, g = 19) : 1 === e ? (U = s, T -= 257, z = o, F -= 257, g = 256) : (U = l, z = d, g = -1), O = 0, p = 0, v = y, _ = f, R = E, A = 0, k = -1, S = 1 << E, m = S - 1, 1 === e && S > 852 || 2 === e && S > 592) return 1; for (; ;) { B = v - A, h[p] < g ? (N = 0, C = h[p]) : h[p] > g ? (N = z[F + h[p]], C = U[T + h[p]]) : (N = 96, C = 0), w = 1 << v - A, b = 1 << R, y = b; do { b -= w, a[_ + (O >> A) + b] = B << 24 | N << 16 | C | 0; } while (0 !== b); for (w = 1 << v - 1; O & w;)w >>= 1; if (0 !== w ? (O &= w - 1, O += w) : O = 0, p++, 0 == --D[v]) { if (v === x) break; v = t[i + h[p]]; } if (v > E && (O & m) !== k) { for (0 === A && (A = E), _ += y, R = v - A, Z = 1 << R; R + A < x && (Z -= D[R + A], !(Z <= 0));)R++, Z <<= 1; if (S += 1 << R, 1 === e && S > 852 || 2 === e && S > 592) return 1; k = O & m, a[k] = E << 24 | R << 16 | _ - f | 0; } } return 0 !== O && (a[_ + O] = v - A << 24 | 64 << 16 | 0), c.bits = E, 0; }, h = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 }; const { Z_FINISH: c, Z_BLOCK: u, Z_TREES: w, Z_OK: b, Z_STREAM_END: k, Z_NEED_DICT: m, Z_STREAM_ERROR: _, Z_DATA_ERROR: g, Z_MEM_ERROR: v, Z_BUF_ERROR: p, Z_DEFLATED: y } = h, x = 12, E = 30, R = e => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24); function A() { this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0; } const Z = e => { if (!e || !e.state) return _; const t = e.state; return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = 1, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(852), t.distcode = t.distdyn = new Int32Array(592), t.sane = 1, t.back = -1, b; }, S = e => { if (!e || !e.state) return _; const t = e.state; return t.wsize = 0, t.whave = 0, t.wnext = 0, Z(e); }, O = (e, t) => { let i; if (!e || !e.state) return _; const n = e.state; return t < 0 ? (i = 0, t = -t) : (i = 1 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? _ : (null !== n.window && n.wbits !== t && (n.window = null), n.wrap = i, n.wbits = t, S(e)); }, U = (e, t) => { if (!e) return _; const i = new A; e.state = i, i.window = null; const n = O(e, t); return n !== b && (e.state = null), n; }; let T, D, I = !0; const B = e => { if (I) { T = new Int32Array(512), D = new Int32Array(32); let t = 0; for (; t < 144;)e.lens[t++] = 8; for (; t < 256;)e.lens[t++] = 9; for (; t < 280;)e.lens[t++] = 7; for (; t < 288;)e.lens[t++] = 8; for (f(1, e.lens, 0, 288, T, 0, e.work, { bits: 9 }), t = 0; t < 32;)e.lens[t++] = 5; f(2, e.lens, 0, 32, D, 0, e.work, { bits: 5 }), I = !1; } e.lencode = T, e.lenbits = 9, e.distcode = D, e.distbits = 5; }, N = (e, t, i, n) => { let a; const r = e.state; return null === r.window && (r.wsize = 1 << r.wbits, r.wnext = 0, r.whave = 0, r.window = new Uint8Array(r.wsize)), n >= r.wsize ? (r.window.set(t.subarray(i - r.wsize, i), 0), r.wnext = 0, r.whave = r.wsize) : (a = r.wsize - r.wnext, a > n && (a = n), r.window.set(t.subarray(i - n, i - n + a), r.wnext), (n -= a) ? (r.window.set(t.subarray(i - n, i), 0), r.wnext = n, r.whave = r.wsize) : (r.wnext += a, r.wnext === r.wsize && (r.wnext = 0), r.whave < r.wsize && (r.whave += a))), 0; }; var C = { inflateReset: S, inflateReset2: O, inflateResetKeep: Z, inflateInit: e => U(e, 15), inflateInit2: U, inflate: (e, i) => { let r, s, o, l, d, h, A, Z, S, O, U, T, D, I, C, z, F, L, M, H, j, K, P = 0; const Y = new Uint8Array(4); let G, X; const W = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return _; r = e.state, r.mode === x && (r.mode = 13), d = e.next_out, o = e.output, A = e.avail_out, l = e.next_in, s = e.input, h = e.avail_in, Z = r.hold, S = r.bits, O = h, U = A, K = b; e: for (; ;)switch (r.mode) { case 1: if (0 === r.wrap) { r.mode = 13; break; } for (; S < 16;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } if (2 & r.wrap && 35615 === Z) { r.check = 0, Y[0] = 255 & Z, Y[1] = Z >>> 8 & 255, r.check = n(r.check, Y, 2, 0), Z = 0, S = 0, r.mode = 2; break; } if (r.flags = 0, r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & Z) << 8) + (Z >> 8)) % 31) { e.msg = "incorrect header check", r.mode = E; break; } if ((15 & Z) !== y) { e.msg = "unknown compression method", r.mode = E; break; } if (Z >>>= 4, S -= 4, j = 8 + (15 & Z), 0 === r.wbits) r.wbits = j; else if (j > r.wbits) { e.msg = "invalid window size", r.mode = E; break; } r.dmax = 1 << r.wbits, e.adler = r.check = 1, r.mode = 512 & Z ? 10 : x, Z = 0, S = 0; break; case 2: for (; S < 16;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } if (r.flags = Z, (255 & r.flags) !== y) { e.msg = "unknown compression method", r.mode = E; break; } if (57344 & r.flags) { e.msg = "unknown header flags set", r.mode = E; break; } r.head && (r.head.text = Z >> 8 & 1), 512 & r.flags && (Y[0] = 255 & Z, Y[1] = Z >>> 8 & 255, r.check = n(r.check, Y, 2, 0)), Z = 0, S = 0, r.mode = 3; case 3: for (; S < 32;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } r.head && (r.head.time = Z), 512 & r.flags && (Y[0] = 255 & Z, Y[1] = Z >>> 8 & 255, Y[2] = Z >>> 16 & 255, Y[3] = Z >>> 24 & 255, r.check = n(r.check, Y, 4, 0)), Z = 0, S = 0, r.mode = 4; case 4: for (; S < 16;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } r.head && (r.head.xflags = 255 & Z, r.head.os = Z >> 8), 512 & r.flags && (Y[0] = 255 & Z, Y[1] = Z >>> 8 & 255, r.check = n(r.check, Y, 2, 0)), Z = 0, S = 0, r.mode = 5; case 5: if (1024 & r.flags) { for (; S < 16;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } r.length = Z, r.head && (r.head.extra_len = Z), 512 & r.flags && (Y[0] = 255 & Z, Y[1] = Z >>> 8 & 255, r.check = n(r.check, Y, 2, 0)), Z = 0, S = 0; } else r.head && (r.head.extra = null); r.mode = 6; case 6: if (1024 & r.flags && (T = r.length, T > h && (T = h), T && (r.head && (j = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Uint8Array(r.head.extra_len)), r.head.extra.set(s.subarray(l, l + T), j)), 512 & r.flags && (r.check = n(r.check, s, T, l)), h -= T, l += T, r.length -= T), r.length)) break e; r.length = 0, r.mode = 7; case 7: if (2048 & r.flags) { if (0 === h) break e; T = 0; do { j = s[l + T++], r.head && j && r.length < 65536 && (r.head.name += String.fromCharCode(j)); } while (j && T < h); if (512 & r.flags && (r.check = n(r.check, s, T, l)), h -= T, l += T, j) break e; } else r.head && (r.head.name = null); r.length = 0, r.mode = 8; case 8: if (4096 & r.flags) { if (0 === h) break e; T = 0; do { j = s[l + T++], r.head && j && r.length < 65536 && (r.head.comment += String.fromCharCode(j)); } while (j && T < h); if (512 & r.flags && (r.check = n(r.check, s, T, l)), h -= T, l += T, j) break e; } else r.head && (r.head.comment = null); r.mode = 9; case 9: if (512 & r.flags) { for (; S < 16;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } if (Z !== (65535 & r.check)) { e.msg = "header crc mismatch", r.mode = E; break; } Z = 0, S = 0; } r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), e.adler = r.check = 0, r.mode = x; break; case 10: for (; S < 32;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } e.adler = r.check = R(Z), Z = 0, S = 0, r.mode = 11; case 11: if (0 === r.havedict) return e.next_out = d, e.avail_out = A, e.next_in = l, e.avail_in = h, r.hold = Z, r.bits = S, m; e.adler = r.check = 1, r.mode = x; case x: if (i === u || i === w) break e; case 13: if (r.last) { Z >>>= 7 & S, S -= 7 & S, r.mode = 27; break; } for (; S < 3;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } switch (r.last = 1 & Z, Z >>>= 1, S -= 1, 3 & Z) { case 0: r.mode = 14; break; case 1: if (B(r), r.mode = 20, i === w) { Z >>>= 2, S -= 2; break e; } break; case 2: r.mode = 17; break; case 3: e.msg = "invalid block type", r.mode = E; }Z >>>= 2, S -= 2; break; case 14: for (Z >>>= 7 & S, S -= 7 & S; S < 32;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } if ((65535 & Z) != (Z >>> 16 ^ 65535)) { e.msg = "invalid stored block lengths", r.mode = E; break; } if (r.length = 65535 & Z, Z = 0, S = 0, r.mode = 15, i === w) break e; case 15: r.mode = 16; case 16: if (T = r.length, T) { if (T > h && (T = h), T > A && (T = A), 0 === T) break e; o.set(s.subarray(l, l + T), d), h -= T, l += T, A -= T, d += T, r.length -= T; break; } r.mode = x; break; case 17: for (; S < 14;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } if (r.nlen = 257 + (31 & Z), Z >>>= 5, S -= 5, r.ndist = 1 + (31 & Z), Z >>>= 5, S -= 5, r.ncode = 4 + (15 & Z), Z >>>= 4, S -= 4, r.nlen > 286 || r.ndist > 30) { e.msg = "too many length or distance symbols", r.mode = E; break; } r.have = 0, r.mode = 18; case 18: for (; r.have < r.ncode;) { for (; S < 3;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } r.lens[W[r.have++]] = 7 & Z, Z >>>= 3, S -= 3; } for (; r.have < 19;)r.lens[W[r.have++]] = 0; if (r.lencode = r.lendyn, r.lenbits = 7, G = { bits: r.lenbits }, K = f(0, r.lens, 0, 19, r.lencode, 0, r.work, G), r.lenbits = G.bits, K) { e.msg = "invalid code lengths set", r.mode = E; break; } r.have = 0, r.mode = 19; case 19: for (; r.have < r.nlen + r.ndist;) { for (; P = r.lencode[Z & (1 << r.lenbits) - 1], C = P >>> 24, z = P >>> 16 & 255, F = 65535 & P, !(C <= S);) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } if (F < 16) Z >>>= C, S -= C, r.lens[r.have++] = F; else { if (16 === F) { for (X = C + 2; S < X;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } if (Z >>>= C, S -= C, 0 === r.have) { e.msg = "invalid bit length repeat", r.mode = E; break; } j = r.lens[r.have - 1], T = 3 + (3 & Z), Z >>>= 2, S -= 2; } else if (17 === F) { for (X = C + 3; S < X;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } Z >>>= C, S -= C, j = 0, T = 3 + (7 & Z), Z >>>= 3, S -= 3; } else { for (X = C + 7; S < X;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } Z >>>= C, S -= C, j = 0, T = 11 + (127 & Z), Z >>>= 7, S -= 7; } if (r.have + T > r.nlen + r.ndist) { e.msg = "invalid bit length repeat", r.mode = E; break; } for (; T--;)r.lens[r.have++] = j; } } if (r.mode === E) break; if (0 === r.lens[256]) { e.msg = "invalid code -- missing end-of-block", r.mode = E; break; } if (r.lenbits = 9, G = { bits: r.lenbits }, K = f(1, r.lens, 0, r.nlen, r.lencode, 0, r.work, G), r.lenbits = G.bits, K) { e.msg = "invalid literal/lengths set", r.mode = E; break; } if (r.distbits = 6, r.distcode = r.distdyn, G = { bits: r.distbits }, K = f(2, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, G), r.distbits = G.bits, K) { e.msg = "invalid distances set", r.mode = E; break; } if (r.mode = 20, i === w) break e; case 20: r.mode = 21; case 21: if (h >= 6 && A >= 258) { e.next_out = d, e.avail_out = A, e.next_in = l, e.avail_in = h, r.hold = Z, r.bits = S, a(e, U), d = e.next_out, o = e.output, A = e.avail_out, l = e.next_in, s = e.input, h = e.avail_in, Z = r.hold, S = r.bits, r.mode === x && (r.back = -1); break; } for (r.back = 0; P = r.lencode[Z & (1 << r.lenbits) - 1], C = P >>> 24, z = P >>> 16 & 255, F = 65535 & P, !(C <= S);) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } if (z && 0 == (240 & z)) { for (L = C, M = z, H = F; P = r.lencode[H + ((Z & (1 << L + M) - 1) >> L)], C = P >>> 24, z = P >>> 16 & 255, F = 65535 & P, !(L + C <= S);) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } Z >>>= L, S -= L, r.back += L; } if (Z >>>= C, S -= C, r.back += C, r.length = F, 0 === z) { r.mode = 26; break; } if (32 & z) { r.back = -1, r.mode = x; break; } if (64 & z) { e.msg = "invalid literal/length code", r.mode = E; break; } r.extra = 15 & z, r.mode = 22; case 22: if (r.extra) { for (X = r.extra; S < X;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } r.length += Z & (1 << r.extra) - 1, Z >>>= r.extra, S -= r.extra, r.back += r.extra; } r.was = r.length, r.mode = 23; case 23: for (; P = r.distcode[Z & (1 << r.distbits) - 1], C = P >>> 24, z = P >>> 16 & 255, F = 65535 & P, !(C <= S);) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } if (0 == (240 & z)) { for (L = C, M = z, H = F; P = r.distcode[H + ((Z & (1 << L + M) - 1) >> L)], C = P >>> 24, z = P >>> 16 & 255, F = 65535 & P, !(L + C <= S);) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } Z >>>= L, S -= L, r.back += L; } if (Z >>>= C, S -= C, r.back += C, 64 & z) { e.msg = "invalid distance code", r.mode = E; break; } r.offset = F, r.extra = 15 & z, r.mode = 24; case 24: if (r.extra) { for (X = r.extra; S < X;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } r.offset += Z & (1 << r.extra) - 1, Z >>>= r.extra, S -= r.extra, r.back += r.extra; } if (r.offset > r.dmax) { e.msg = "invalid distance too far back", r.mode = E; break; } r.mode = 25; case 25: if (0 === A) break e; if (T = U - A, r.offset > T) { if (T = r.offset - T, T > r.whave && r.sane) { e.msg = "invalid distance too far back", r.mode = E; break; } T > r.wnext ? (T -= r.wnext, D = r.wsize - T) : D = r.wnext - T, T > r.length && (T = r.length), I = r.window; } else I = o, D = d - r.offset, T = r.length; T > A && (T = A), A -= T, r.length -= T; do { o[d++] = I[D++]; } while (--T); 0 === r.length && (r.mode = 21); break; case 26: if (0 === A) break e; o[d++] = r.length, A--, r.mode = 21; break; case 27: if (r.wrap) { for (; S < 32;) { if (0 === h) break e; h--, Z |= s[l++] << S, S += 8; } if (U -= A, e.total_out += U, r.total += U, U && (e.adler = r.check = r.flags ? n(r.check, o, U, d - U) : t(r.check, o, U, d - U)), U = A, (r.flags ? Z : R(Z)) !== r.check) { e.msg = "incorrect data check", r.mode = E; break; } Z = 0, S = 0; } r.mode = 28; case 28: if (r.wrap && r.flags) { for (; S < 32;) { if (0 === h) break e; h--, Z += s[l++] << S, S += 8; } if (Z !== (4294967295 & r.total)) { e.msg = "incorrect length check", r.mode = E; break; } Z = 0, S = 0; } r.mode = 29; case 29: K = k; break e; case E: K = g; break e; case 31: return v; case 32: default: return _; }return e.next_out = d, e.avail_out = A, e.next_in = l, e.avail_in = h, r.hold = Z, r.bits = S, (r.wsize || U !== e.avail_out && r.mode < E && (r.mode < 27 || i !== c)) && N(e, e.output, e.next_out, U - e.avail_out), O -= e.avail_in, U -= e.avail_out, e.total_in += O, e.total_out += U, r.total += U, r.wrap && U && (e.adler = r.check = r.flags ? n(r.check, o, U, e.next_out - U) : t(r.check, o, U, e.next_out - U)), e.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === x ? 128 : 0) + (20 === r.mode || 15 === r.mode ? 256 : 0), (0 === O && 0 === U || i === c) && K === b && (K = p), K; }, inflateEnd: e => { if (!e || !e.state) return _; let t = e.state; return t.window && (t.window = null), e.state = null, b; }, inflateGetHeader: (e, t) => { if (!e || !e.state) return _; const i = e.state; return 0 == (2 & i.wrap) ? _ : (i.head = t, t.done = !1, b); }, inflateSetDictionary: (e, i) => { const n = i.length; let a, r, s; return e && e.state ? (a = e.state, 0 !== a.wrap && 11 !== a.mode ? _ : 11 === a.mode && (r = 1, r = t(r, i, n, 0), r !== a.check) ? g : (s = N(e, i, n, n), s ? (a.mode = 31, v) : (a.havedict = 1, b))) : _; }, inflateInfo: "pako inflate (from Nodeca project)" }; const z = (e, t) => Object.prototype.hasOwnProperty.call(e, t); var F = function (e) { const t = Array.prototype.slice.call(arguments, 1); for (; t.length;) { const i = t.shift(); if (i) { if ("object" != typeof i) throw new TypeError(i + "must be non-object"); for (const t in i) z(i, t) && (e[t] = i[t]); } } return e; }, L = e => { let t = 0; for (let i = 0, n = e.length; i < n; i++)t += e[i].length; const i = new Uint8Array(t); for (let t = 0, n = 0, a = e.length; t < a; t++) { let a = e[t]; i.set(a, n), n += a.length; } return i; }; let M = !0; try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (e) { M = !1; } const H = new Uint8Array(256); for (let e = 0; e < 256; e++)H[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1; H[254] = H[254] = 1; var j = e => { let t, i, n, a, r, s = e.length, o = 0; for (a = 0; a < s; a++)i = e.charCodeAt(a), 55296 == (64512 & i) && a + 1 < s && (n = e.charCodeAt(a + 1), 56320 == (64512 & n) && (i = 65536 + (i - 55296 << 10) + (n - 56320), a++)), o += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4; for (t = new Uint8Array(o), r = 0, a = 0; r < o; a++)i = e.charCodeAt(a), 55296 == (64512 & i) && a + 1 < s && (n = e.charCodeAt(a + 1), 56320 == (64512 & n) && (i = 65536 + (i - 55296 << 10) + (n - 56320), a++)), i < 128 ? t[r++] = i : i < 2048 ? (t[r++] = 192 | i >>> 6, t[r++] = 128 | 63 & i) : i < 65536 ? (t[r++] = 224 | i >>> 12, t[r++] = 128 | i >>> 6 & 63, t[r++] = 128 | 63 & i) : (t[r++] = 240 | i >>> 18, t[r++] = 128 | i >>> 12 & 63, t[r++] = 128 | i >>> 6 & 63, t[r++] = 128 | 63 & i); return t; }, K = (e, t) => { let i, n; const a = t || e.length, r = new Array(2 * a); for (n = 0, i = 0; i < a;) { let t = e[i++]; if (t < 128) { r[n++] = t; continue; } let s = H[t]; if (s > 4) r[n++] = 65533, i += s - 1; else { for (t &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && i < a;)t = t << 6 | 63 & e[i++], s--; s > 1 ? r[n++] = 65533 : t < 65536 ? r[n++] = t : (t -= 65536, r[n++] = 55296 | t >> 10 & 1023, r[n++] = 56320 | 1023 & t); } } return ((e, t) => { if (t < 65534 && e.subarray && M) return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t)); let i = ""; for (let n = 0; n < t; n++)i += String.fromCharCode(e[n]); return i; })(r, n); }, P = (e, t) => { (t = t || e.length) > e.length && (t = e.length); let i = t - 1; for (; i >= 0 && 128 == (192 & e[i]);)i--; return i < 0 || 0 === i ? t : i + H[e[i]] > t ? i : t; }, Y = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }; var G = function () { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0; }; var X = function () { this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1; }; const W = Object.prototype.toString, { Z_NO_FLUSH: q, Z_FINISH: J, Z_OK: Q, Z_STREAM_END: V, Z_NEED_DICT: $, Z_STREAM_ERROR: ee, Z_DATA_ERROR: te, Z_MEM_ERROR: ie } = h; function ne(e) { this.options = F({ chunkSize: 65536, windowBits: 15, to: "" }, e || {}); const t = this.options; t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(t.windowBits >= 0 && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new G, this.strm.avail_out = 0; let i = C.inflateInit2(this.strm, t.windowBits); if (i !== Q) throw new Error(Y[i]); if (this.header = new X, C.inflateGetHeader(this.strm, this.header), t.dictionary && ("string" == typeof t.dictionary ? t.dictionary = j(t.dictionary) : "[object ArrayBuffer]" === W.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (i = C.inflateSetDictionary(this.strm, t.dictionary), i !== Q))) throw new Error(Y[i]); } function ae(e, t) { const i = new ne(t); if (i.push(e), i.err) throw i.msg || Y[i.err]; return i.result; } ne.prototype.push = function (e, t) { const i = this.strm, n = this.options.chunkSize, a = this.options.dictionary; let r, s, o; if (this.ended) return !1; for (s = t === ~~t ? t : !0 === t ? J : q, "[object ArrayBuffer]" === W.call(e) ? i.input = new Uint8Array(e) : i.input = e, i.next_in = 0, i.avail_in = i.input.length; ;) { for (0 === i.avail_out && (i.output = new Uint8Array(n), i.next_out = 0, i.avail_out = n), r = C.inflate(i, s), r === $ && a && (r = C.inflateSetDictionary(i, a), r === Q ? r = C.inflate(i, s) : r === te && (r = $)); i.avail_in > 0 && r === V && i.state.wrap > 0 && 0 !== e[i.next_in];)C.inflateReset(i), r = C.inflate(i, s); switch (r) { case ee: case te: case $: case ie: return this.onEnd(r), this.ended = !0, !1; }if (o = i.avail_out, i.next_out && (0 === i.avail_out || r === V)) if ("string" === this.options.to) { let e = P(i.output, i.next_out), t = i.next_out - e, a = K(i.output, e); i.next_out = t, i.avail_out = n - t, t && i.output.set(i.output.subarray(e, e + t), 0), this.onData(a); } else this.onData(i.output.length === i.next_out ? i.output : i.output.subarray(0, i.next_out)); if (r !== Q || 0 !== o) { if (r === V) return r = C.inflateEnd(this.strm), this.onEnd(r), this.ended = !0, !0; if (0 === i.avail_in) break; } } return !0; }, ne.prototype.onData = function (e) { this.chunks.push(e); }, ne.prototype.onEnd = function (e) { e === Q && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = L(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg; }; var re = ne, se = ae, oe = function (e, t) { return (t = t || {}).raw = !0, ae(e, t); }, le = ae, de = h, fe = { Inflate: re, inflate: se, inflateRaw: oe, ungzip: le, constants: de }; e.Inflate = re, e.constants = de, e.default = fe, e.inflate = se, e.inflateRaw = oe, e.ungzip = le, Object.defineProperty(e, "__esModule", { value: !0 }); }));</script>
        <!-- #vis-networkjs -->
        <style>
            .head{touch-action:none}.minimized{height:30px}.autosize{width:auto!important;height:auto!important;max-width:100%!important;max-height:100%!important;overflow:auto!important}.modal-dialog{position:fixed;background-color:rgba(240,248,255,.66);color:#000;width:800px;height:600px;resize:both;font-family:monospace;z-index:5000;display:flex;flex-direction:column;overflow:hidden}.modal-content table{width:100%;height:100%;border:2px solid #000;padding:2px}.modal-content table tr td{border-bottom-style:solid;border-bottom-width:thin;border-bottom-color:#dcdcdc;font-size:12px;border:1px solid #ddd}.modal-content table tr:nth-child(2n){background-color:#f2f2f2}.centered-text{text-align:center}.active-machine-or-state{color:#fff;background-color:#00008b}.parallel-machine{color:#fff;background-color:#006400}.modal-content table tr.selectableoption:focus,.modal-content table tr.selectableoption:hover{color:#fff;background-color:rgba(0,140,0,.66);text-decoration:none;cursor:pointer}.modal-content table tr.selectablerow:focus,.modal-content table tr.selectablerow:hover{color:#fff;background-color:rgba(0,0,140,.66);text-decoration:none;cursor:pointer}.modal-content table tr td.propvalue:focus,.modal-content table tr td.propvalue:hover{color:#fff;background-color:rgba(0,0,255,.66);text-decoration:none;cursor:text}.modal-content table tr td.state:focus,.modal-content table tr td.state:hover{color:#fff;background-color:rgba(0,0,255,.66);text-decoration:none;cursor:pointer}.modal-content table tr td.mutated-propvalue{color:#fff;background-color:rgba(140,0,0,.66)}.modal-content table tr td.mutated-propvalue:focus,.modal-content table tr td.mutated-propvalue:hover{color:#fff;background-color:rgba(255,0,0,.66)}.modal-content table tr td.immutable-propvalue:focus,.modal-content table tr td.immutable-propvalue:hover{color:#fff;background-color:rgba(128,128,128,.66);text-decoration:none;cursor:not-allowed}.modal-content table tr td.undefined-propvalue{color:#2f4f4f;font-style:italic}.modal-content table tr td.undefined-propvalue:focus,.modal-content table tr td.undefined-propvalue:hover{color:#fff;background-color:rgba(0,0,255,.66);text-decoration:none;cursor:text}.modal-content table tr td.empty-propvalue{color:#2f4f4f;font-style:italic}.modal-content table tr td.empty-propvalue:focus,.modal-content table tr td.empty-propvalue:hover{background-color:rgba(128,128,128,.66);cursor:not-allowed}.modal-content table tr td.excluded-propvalue{color:#2f4f4f;font-style:italic;text-decoration:line-through}.modal-content table tr td.excluded-propvalue:focus,.modal-content table tr td.excluded-propvalue:hover{background-color:rgba(128,128,128,.66);cursor:not-allowed}.modal-content table tr td:first-of-type{font-weight:700;text-decoration:underline;border-right-style:solid;border-right-width:thin;border-right-color:#dcdcdc}.modal-content table tr th{text-align:left;color:#fff;background-color:rgba(0,0,0,.66)}.modal-content{background-color:#fafafaaa;margin:20px;border:1px solid #888;overflow:auto}.modal-title-wrapper{text-align:center;background:rgba(120,136,154,.66);white-space:nowrap}.modal-dialog-button{color:#fff;text-align:right;font-size:28px;font-weight:700;margin-right:20px;padding-left:8px;padding-right:8px;float:right}.modal-back{color:#fff;text-align:left;font-size:28px;font-weight:700;margin-left:20px;padding-left:8px;padding-right:8px;float:left}.modal-title{color:#000;font-size:28px;font-weight:700;display:inline-block}.fullscreen{top:0;left:0;width:100%;min-height:100%}.modal-back:focus,.modal-back:hover,.modal-dialog-button:focus,.modal-dialog-button:hover{color:#fff;background:rgba(10,7,7,.66);text-decoration:none;cursor:pointer}.knop{pointer-events:auto;touch-action:auto;z-index:2000;opacity:1;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-touch-callout:none;fill:transparent;font-family:'Press Start 2P';text-anchor:middle;font-size:11px;transform:perspective(5px) translateZ(2px)}.knop.hidden{display:none}#button-controls{pointer-events:none;touch-action:none;opacity:1}#d-pad-controls{pointer-events:none;touch-action:none;opacity:1}.knoptext{fill:gainsboro}.knop:not(.los){transform:translateY(2px);filter:url(#pressedButtonFilter)}.knop.los{animation:button-los .5s forwards cubic-bezier(.18,.89,.32,1.28)}.knop.red{fill:#FF4E00}.knop.blue{fill:#003791}.knop.green{fill:#008740}.knop.pink{fill:#FF80C0}.knop.orange{fill:#FFA500}.knop.purple{fill:#800080}.knop.light-blue{fill:#00BFFF}.knop.yellow{fill:#FFFF00}@keyframes button-los{from{transform:translateY(2px);filter:url(#pressedButtonFilter)}to{transform:none;filter:url(#buttonFilter)}}#d-pad-svg{transform-origin:left bottom}#action-buttons-svg{transform-origin:right bottom}svg.d-pad{position:absolute;z-index:2000;pointer-events:auto;touch-action:auto;left:0}svg.action-buttons{position:absolute;z-index:2000;pointer-events:auto;touch-action:auto;right:0}.dknop{pointer-events:auto;touch-action:auto;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-touch-callout:none}@keyframes dknop-los{from{fill:rgb(252,172,0)}to{fill:black}}.dknop.los{animation:dknop-los 1s forwards cubic-bezier(.18,.89,.32,1.28)}.dknop.druk{fill:rgb(252,172,0)}.dstick{stroke-width:1px;z-index:2001}#d-pad-omheining{stroke:gainsboro;fill:transparent}body{position:fixed;margin:0;padding:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-touch-callout:none;-webkit-user-drag:none;overflow:hidden;background-color:#2020ff;cursor:auto;min-height:100%;width:100vw;height:100%}body.game-started{background-color:#101010}html{width:100vw;height:100%}#gameContainer{position:relative}#debugPanel{position:absolute;top:10px;right:10px;background-color:transparent;z-index:1000;fill-opacity:0.25}.debugIcon{width:40px;height:40px;margin:5px;cursor:pointer}#gamescreen{position:fixed;transform-origin:0 0;-ms-interpolation-mode:nearest-neighbor;image-rendering:pixelated;overflow:hidden;display:none;z-index:-1;background-color:#000}#hidor{z-index:1000;position:absolute;top:60vh;left:0;width:100%;height:100%;background-color:#2020ff}.showsover{animation:colorto_showsover 1s forwards linear}#msx{position:absolute;margin-left:auto;margin-right:auto;width:40%;left:50%}#msx.hidden{transform:translateX(-50%) translateY(65vh)}#msx.enter{animation:enter 1s forwards linear;transform:translateX(-50%) translateY(65vh);display:block}@keyframes enter{from{transform:translateX(-50%) translateY(65vh)}to{transform:translateX(-50%) translateY(calc(60vh - 100%))}}@keyframes colorto_showsover{from{background-color:#2020ff}to{background-color:red}}#loading{z-index:1001;margin-left:auto;margin-right:auto;width:100vw;position:absolute;top:60vh;color:#fff;font-family:monospace;font-size:x-large;text-align:center}#loading.appear{animation:fade-in-partial 1s infinite linear alternate}#loading.fadeout{animation:fade-out 1s linear forwards}#loading.coloring{animation:coloring 2s infinite}@keyframes coloring{0%{color:#fff}50%{color:#2020ff}100%{color:#fff}}@keyframes fade-in-partial{from{opacity:.3}to{opacity:1}}@keyframes fade-in{from{opacity:0}to{opacity:1}}@keyframes fade-out{from{opacity:1}to{opacity:0}}
        </style>
    </head>

    <body>
        <div>
            <img id="msx" class="hidden" src="data:image/png;base64,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" alt="MSX" hidden>
            <div id="hidor"></div>
            <div id="loading" class="coloring" hidden>Loading...</div>
            <!-- Button controls -->
            <div id="d-pad-controls" hidden>
                <svg id="d-pad-svg" class="d-pad" viewBox="0 0 100 100" width="100px" height="100px">
                    <g id="d-pad-buttons">
                        <path id="d-pad-u" class="dknop los"
                            d="M 50 50 L 50 39 A 11 11, 0, 0, 1, 60 44 L 50 50 L 50 0 A 51 51, 0, 0, 1, 91 21 Z"
                            transform="rotate(-27 50 50)" />
                        <path id="d-pad-ru" class="dknop los"
                            d="M 50 50 L 50 39 A 11 11, 0, 0, 1, 58 42 L 50 50 L 50 0 A 51 51, 0, 0, 1, 80 10"
                            transform="rotate(27 50 50)" />
                        <path id="d-pad-r" class="dknop los"
                            d="M 50 50 L 50 39 A 11 11, 0, 0, 1, 60 44 L 50 50 L 50 0 A 51 51, 0, 0, 1, 91 21 Z"
                            transform="rotate(63 50 50)" />
                        <path id="d-pad-rd" class="dknop los"
                            d="M 50 50 L 50 39 A 11 11, 0, 0, 1, 58 42 L 50 50 L 50 0 A 51 51, 0, 0, 1, 80 10"
                            transform="rotate(117 50 50)" />
                        <path id="d-pad-d" class="dknop los"
                            d="M 50 50 L 50 39 A 11 11, 0, 0, 1, 60 44 L 50 50 L 50 0 A 51 51, 0, 0, 1, 91 21 Z"
                            transform="rotate(153 50 50)" />
                        <path id="d-pad-ld" class="dknop los"
                            d="M 50 50 L 50 39 A 11 11, 0, 0, 1, 58 42 L 50 50 L 50 0 A 51 51, 0, 0, 1, 80 10"
                            transform="rotate(207 50 50)" />
                        <path id="d-pad-l" class="dknop los"
                            d="M 50 50 L 50 39 A 11 11, 0, 0, 1, 60 44 L 50 50 L 50 0 A 51 51, 0, 0, 1, 91 21 Z"
                            transform="rotate(243 50 50)" />
                        <path id="d-pad-lu" class="dknop los"
                            d="M 50 50 L 50 38 A 11 11, 0, 0, 1, 50 50 L 50 50 L 50 0 A 52 52, 0, 0, 1, 82 12"
                            transform="rotate(297 50 50)" />
                    </g>
                    <g>
                        <circle id="d-pad-omheining" class="dstick" cx="50" cy="50" r="50" />
                        <!-- <circle id="d-pad-dmz" class="dstick" cx="50" cy="50" r="40" />
                        <circle id="d-pad-innercircle" class="dstick" cx="50" cy="50" r="10" /> -->
                    </g>
                </svg>
            </div>
            <div id="button-controls" hidden>
                <svg id="action-buttons-svg" class="action-buttons" viewBox="0 0 100 220" width="100px" height="220px">
                    <defs>
                        <filter id="buttonFilter" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur in="SourceAlpha" stdDeviation="4" result="blur" />
                            <feOffset in="blur" dx="4" dy="4" result="offsetBlur" />
                            <feSpecularLighting in="blur" surfaceScale="5" specularConstant=".75" specularExponent="30"
                                lighting-color="#999999" result="specOut">
                                <fePointLight x="-5000" y="-10000" z="20000" />
                            </feSpecularLighting>
                            <feComposite in="specOut" in2="SourceAlpha" operator="in" result="specOut" />
                            <feComposite in="SourceGraphic" in2="specOut" operator="arithmetic" k1="0" k2="1" k3="1"
                                k4="0" />
                        </filter>
                    </defs>
                    <filter id="pressedButtonFilter" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur in="SourceAlpha" stdDeviation="4" result="blur" />
                        <feOffset in="blur" dx="2" dy="2" result="offsetBlur" />
                        <feSpecularLighting in="blur" surfaceScale="5" specularConstant=".75" specularExponent="30"
                            lighting-color="#999999" result="specOut">
                            <fePointLight x="-5000" y="-10000" z="5000" />
                        </feSpecularLighting>
                        <feComposite in="specOut" in2="SourceAlpha" operator="in" result="specOut" />
                        <feComposite in="SourceGraphic" in2="specOut" operator="arithmetic" k1="0" k2="1" k3="1"
                            k4="0" />
                    </filter>
                    <g class="buttons" id="action-buttons-container">
                        <circle id="start_knop" class="knop light-blue los" cx="50" cy="200" r="20"></circle>
                        <text id="start_knop_text" x="50" y="200" dominant-baseline="middle"
                            class="knop knoptext los">ST</text>

                        <circle id="select_knop" class="knop yellow los" cx="20" cy="170" r="20"></circle>
                        <text id="select_knop_text" x="20" y="170" dominant-baseline="middle"
                            class="knop knoptext los">SE</text>

                        <circle id="ls_knop" class="knop orange los" cx="50" cy="20" r="20"></circle>
                        <text id="ls_knop_text" x="50" y="20" dominant-baseline="middle" class="knop knoptext los">LS</text>

                        <circle id="rs_knop" class="knop purple los" cx="80" cy="50" r="20"></circle>
                        <text id="rs_knop_text" x="80" y="50" dominant-baseline="middle" class="knop knoptext los">RS</text>

                        <circle id="a_knop" class="knop blue los" cx="50" cy="140" r="20"></circle>
                        <text id="a_knop_text" x="50" y="140" dominant-baseline="middle" class="knop knoptext los">A</text>

                        <circle id="b_knop" class="knop red los" cx="80" cy="110" r="20"></circle>
                        <text id="b_knop_text" x="80" y="110" dominant-baseline="middle" class="knop knoptext los">B</text>

                        <circle id="x_knop" class="knop pink los" cx="20" cy="110" r="20"></circle>
                        <text id="x_knop_text" x="20" y="110" dominant-baseline="middle" class="knop knoptext los">X</text>

                        <circle id="y_knop" class="knop green los" cx="50" cy="80" r="20"></circle>
                        <text id="y_knop_text" x="50" y="80" dominant-baseline="middle" class="knop knoptext los">Y</text>
                    </g>
                </svg>
            </div>
            <div id="gameContainer">
                <canvas id="gamescreen" hidden></canvas>
            </div>
        </div>
    </body>
    <script>
        bootrom.debug = true;
		bootrom.romname = getRomNameFromUrlParameter() ?? 'yiear';

        const romurl = getRomFromUrlParameter() ?? 'yiear.rom';
        bootrom.bload(`./${romurl}`).then(function (h406A) {
            bootrom.defusr = h406A;
            bootrom.usr(0);
        }).catch(function (err) {
            bootrom.outputError(err?.message ?? err);
        });
    </script>

</html>